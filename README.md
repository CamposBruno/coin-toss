# TossIt ðŸª™

A simple and educational Ethereum smart contract for a coin toss game built with [Foundry](https://getfoundry.sh/) that uses [Chainlink VRF](https://docs.chain.link/vrf) for verifiable randomness.

## Overview

TossIt is a decentralized coin toss game where two players can join and compete in a simple heads-or-tails game. The first player chooses heads or tails, and the second player automatically gets the opposite choice. The winner is determined by a verifiable coin toss using Chainlink VRF (Verifiable Random Function) for provably fair randomness.

## Features

- **Simple Game Mechanics**: Easy-to-understand heads-or-tails gameplay
- **Two-Player System**: Supports exactly two players per game
- **Automatic Side Assignment**: Second player automatically gets the opposite choice
- **Verifiable Randomness**: Uses Chainlink VRF for provably fair randomness
- **Subscription Management**: Built-in VRF subscription management
- **Event Logging**: Comprehensive event emission for game tracking
- **View Functions**: Easy access to game state and player information
- **Educational Focus**: Well-documented code for learning purposes

## Game Flow

1. **Game Initialization**: The first player deploys the contract and chooses heads or tails
2. **Player Joining**: The second player joins and automatically gets the opposite choice
3. **Randomness Request**: When the second player joins, a VRF request is automatically made
4. **Coin Toss**: Either player can trigger the coin toss once randomness is fulfilled (typically 3+ blocks later)
5. **Winner Declaration**: The player whose choice matches the toss result wins

## Smart Contract Functions

### Core Functions
- `joinGame()` - Allows the second player to join the game and triggers VRF request
- `tossCoin()` - Simulates a coin toss using VRF randomness and determines the winner

### View Functions
- `getGameDetails()` - Returns complete game state information
- `getPlayerDetails(bool isPlayer1)` - Returns details for a specific player

### Events
- `JoinedGame(address indexed player1, address indexed player2)` - Emitted when the second player joins
- `GameOutcome(address indexed winner, bool outcome)` - Emitted when the game concludes

## Chainlink VRF Integration

### Why Use VRF for Randomness?

The contract uses Chainlink VRF instead of simple pseudo-randomness for several critical reasons:

1. **Provable Fairness**: VRF provides cryptographically verifiable randomness that cannot be manipulated by miners, validators, or other participants
2. **Tamper Resistance**: Unlike block-based randomness (timestamp, blockhash), VRF results cannot be predicted or influenced by the transaction submitter
3. **Decentralized Security**: The randomness is generated by a decentralized network of Chainlink nodes, ensuring no single point of failure
4. **Audit Trail**: All randomness requests and fulfillments are recorded on-chain for transparency and verification
5. **Production Ready**: VRF is battle-tested and used by major DeFi protocols and gaming applications

### VRF Subscription Management

The contract includes a comprehensive `RandomnessManagerV1` that handles VRF subscription management:

#### Key Features:
- **Automatic Subscription Creation**: Creates a VRF subscription during contract deployment
- **Flexible Funding**: Supports both LINK token and native currency (ETH) payments
- **Consumer Management**: Can add/remove consumer contracts from the subscription
- **Role-Based Access Control**: Uses OpenZeppelin's AccessControl for secure management

#### Subscription Management Functions:
- `fundSubscription(uint256 amount)` - Fund the subscription with LINK or native currency
- `addConsumer(address consumerAddress)` - Add a consumer contract to the subscription
- `removeConsumer(address consumerAddress)` - Remove a consumer from the subscription
- `cancelSubscription(address receivingWallet)` - Cancel subscription and recover funds

#### Configuration Functions:
- `setKeyHash(bytes32 newKeyHash)` - Update the VRF key hash
- `setCallbackGasLimit(uint32 newCallbackGasLimit)` - Adjust gas limits
- `setRequestConfirmations(uint16 newRequestConfirmations)` - Set confirmation blocks
- `setNativePayment(bool newNativePayment)` - Switch between LINK and native payments

### Randomness Request Flow

1. **Request Phase**: When the second player joins, `requestRandomWords(1)` is called
2. **Confirmation Period**: VRF waits for the specified number of block confirmations (default: 3)
3. **Fulfillment**: Chainlink nodes generate and submit the random number
4. **Callback**: `fulfillRandomWords()` is called with the random result
5. **Game Execution**: Players can now call `tossCoin()` to use the verified randomness

## Technology Stack

- **Solidity**: ^0.8.24
- **Foundry**: For development, testing, and deployment
- **Chainlink VRF V2 Plus**: For verifiable randomness
- **OpenZeppelin**: For security utilities (ReentrancyGuard, AccessControl)
- **Forge Standard Library**: For testing utilities

## Prerequisites

- [Foundry](https://getfoundry.sh/) installed on your system
- Basic knowledge of Solidity and Ethereum development
- Understanding of Chainlink VRF concepts
- Testnet LINK tokens for testing (available at [Chainlink Faucets](https://faucets.chain.link/))

## Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd TossIt
```

2. Install dependencies:
```bash
forge install
```

## Usage

### Building the Contract

```bash
forge build
```

### Running Tests

```bash
forge test
```

For verbose test output:
```bash
forge test -vv
```

### Formatting Code

```bash
forge fmt
```

### Gas Snapshots

```bash
forge snapshot
```

### Local Development

Start a local Anvil instance:
```bash
anvil
```

### Deployment

#### Deploy RandomnessManagerV1 First

```bash
forge script script/DeployRandomnessManager.s.sol:DeployRandomnessManagerScript --rpc-url <your_rpc_url> --private-key <your_private_key> --broadcast
```

#### Deploy CoinToss Contract

```bash
forge script script/CointToss.s.sol:CoinTossScript --rpc-url <your_rpc_url> --private-key <your_private_key> --broadcast
```

### VRF Setup Requirements

1. **Fund the Subscription**: After deployment, fund the VRF subscription with LINK or ETH
2. **Grant Roles**: Grant the `RANDOMNESS_AGENT_ROLE` to the CoinToss contract
3. **Configure Parameters**: Set appropriate gas limits and confirmation blocks for your network

## Contract Architecture

### Data Structures

- `PlayerDetails`: Stores player address and their choice (heads/tails)
- `GameRandomness`: Contains VRF manager reference and request ID
- `Game`: Contains complete game state including both players, winner, outcome, and randomness details
- `GameInitialization`: Used for contract deployment with initial player choice and VRF configuration

### Security Considerations

âœ… **Production Ready**: This contract uses Chainlink VRF for verifiable randomness, making it suitable for production use where fairness is critical.

#### Security Features:
- **Reentrancy Protection**: Uses OpenZeppelin's ReentrancyGuard
- **Role-Based Access Control**: Secure management of VRF operations
- **Staleness Protection**: Prevents games from being played too early or too late
- **Input Validation**: Comprehensive parameter validation
- **Interface Compliance**: Ensures VRF manager implements required interface

#### VRF Security Benefits:
- **Unpredictable**: Randomness cannot be predicted before fulfillment
- **Unmanipulatable**: Results cannot be influenced by miners or validators
- **Verifiable**: All randomness can be cryptographically verified
- **Decentralized**: No single point of failure or control

## Testing

The contract includes comprehensive tests covering:

- Game joining functionality with VRF integration
- Coin toss mechanics using verifiable randomness
- VRF request and fulfillment flows
- Subscription management operations
- Error conditions and edge cases
- Access control validation
- Mock VRF coordinator integration

Run the test suite:
```bash
forge test
```

## Network Configuration

### Supported Networks

The contract is designed to work on any network that supports Chainlink VRF V2 Plus:

- **Ethereum Mainnet**: Production deployment
- **Ethereum Sepolia**: Testnet deployment
- **Polygon Mainnet**: Production deployment
- **Polygon Mumbai**: Testnet deployment
- **Arbitrum One**: Production deployment
- **Arbitrum Sepolia**: Testnet deployment

### Network-Specific Setup

Each network requires specific configuration:

1. **VRF Coordinator Address**: Network-specific VRF coordinator contract
2. **LINK Token Address**: Network-specific LINK token contract
3. **Key Hash**: Network-specific key hash for gas lane selection
4. **Subscription Funding**: Network-specific LINK or native currency amounts

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request

## License

see the LICENSE file for details.

## Author

**Bruno Campos** - [bhncampos@gmail.com](mailto:bhncampos@gmail.com)

## Disclaimer

This smart contract is designed for educational purposes but uses production-ready Chainlink VRF for randomness. While the VRF integration provides verifiable randomness, the contract should still be audited before use in production environments where significant value is at stake.
